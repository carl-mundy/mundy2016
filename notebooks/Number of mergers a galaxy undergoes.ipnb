{
 "cells": [
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# Number of mergers a galaxy undergoes across a redshift range"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 1,
   "metadata": {
    "collapsed": true
   },
   "outputs": [],
   "source": [
    "%matplotlib inline"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 8,
   "metadata": {
    "collapsed": false
   },
   "outputs": [],
   "source": [
    "# Import everything we need for this calculation\n",
    "import numpy as np\n",
    "from astropy.cosmology import FlatLambdaCDM\n",
    "from scipy.integrate import quad\n",
    "import astropy.units as u\n",
    "import matplotlib.pyplot as plt\n",
    "\n",
    "# Set the cosmology we are using\n",
    "cosmo = FlatLambdaCDM(H0=70, Om0=0.3)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Define the function which provides the average time between mergers. In Ownsworth et al. (2014), this is given by $\\Gamma$ and defined as $\\tau_m / f_m(z)$. The merger fraction (careful to note this is the *merger* fraction and not the *pair* fraction) is usually given by the form $f_m = f_0(1+z)^m$."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 9,
   "metadata": {
    "collapsed": true
   },
   "outputs": [],
   "source": [
    "def Gamma_fn(z, tau_m, f0, m, C=0.6):\n",
    "    \"\"\"\n",
    "    Average time between merger events, Gamma(z).\n",
    "    \n",
    "    Args:\n",
    "        z (float): redshift;\n",
    "        tau_m (astropy quantity): timescale over which merging is visible;\n",
    "        f0 (float): merger fraction at z = 0;\n",
    "        m (float): slope of the merger fraction, of form f_m = f0(1+z)**m;\n",
    "        C (float): fraction of pairs that actually merger;\n",
    "    \n",
    "    \"\"\"\n",
    "    # Average time between mergers = tau_m / f_m\n",
    "    return tau_m / ((f0*(1+z)**m)*C)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "The number of mergers a galaxy experiences, on average, is then the integral of this function over time. This is written as $N_\\text{merg} = \\int_{z_1}^{z_2} \\frac{dt}{\\Gamma(z)}$.\n",
    "\n",
    "Ownsworth et al. (2014) put this in terms of redshift as $N_\\text{merg} = \\int_{z_1}^{z_2} \\frac{1}{\\Gamma(z)}\\frac{t_H}{(1+z)}\\frac{dz}{E(z)}$, where $E(z) = H(z)$.\n",
    "\n",
    "**However**, I don't think this is right as $dt = \\frac{- dz}{H_0 (1+z) E(z)} = \\frac{- dz}{(1+z) H(z)}$ and many cosmology texts put $E(z) = H(z)/H_0$. This translates to an integrand of\n",
    "\n",
    "$$ N_\\text{merg} = -1 \\times \\int_{z_1}^{z_2} \\frac{1}{\\Gamma(z) (1+z) H(z)} dz$$"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 10,
   "metadata": {
    "collapsed": true
   },
   "outputs": [],
   "source": [
    "def int_fn(z, tau_m, f0, m, fn='mundy', C_merg=0.6):\n",
    "    \"\"\"\n",
    "    The function to integrate wrt to redshift.\n",
    "    \n",
    "    Args:\n",
    "        z (float): redshift;\n",
    "        tau_m (astropy quantity): timescale over which merging is visible;\n",
    "        f0 (float): merger fraction at z = 0;\n",
    "        m (float): slope of the merger fraction, of form f_m = f0(1+z)**m;\n",
    "        fn (str): either 'mundy' or 'ownsworth' to choose integral (see above text);\n",
    "        C (float): fraction of pairs that actually merger;\n",
    "    \"\"\"\n",
    "    if fn == 'mundy':\n",
    "        # Mundy et al. (2016)\n",
    "        return -1. * np.divide(1., Gamma_fn(z, tau_m, f0, m, C_merg) * cosmo.H(z) * (1+z))\n",
    "    elif fn == 'ownsworth':\n",
    "        # Ownsworth et al. (2014)\n",
    "        return -1 * Gamma_fn(z, tau_m, f0, m, C_merg)**(-1) * cosmo.hubble_time * cosmo.H(z) / (1+z)\n",
    "    else:\n",
    "        return False"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Work out the number of mergers a galaxy undergoes across a redshift range, and the associated error on this value.\n",
    "\n",
    "To do this, we generate N samples of the parameters from a normal distribution using their average values and associated errors."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 12,
   "metadata": {
    "collapsed": false
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Using 999 / 1000 realizations...\n",
      "N_merg = 0.34 (+0.22, -0.11)\n"
     ]
    },
    {
     "data": {
      "text/plain": [
       "<matplotlib.text.Text at 0x2b6dac905810>"
      ]
     },
     "execution_count": 12,
     "metadata": {},
     "output_type": "execute_result"
    },
    {
     "data": {
      "image/png": "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\n",
      "text/plain": [
       "<matplotlib.figure.Figure at 0x2b6dac8fde90>"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    }
   ],
   "source": [
    "# =====================================\n",
    "# Best-fit parameters and their errors\n",
    "# =====================================\n",
    "# # Ownsworth et al. (2014)\n",
    "# tau_m, e_tau_m = 0.4, 0.2\n",
    "# f0, e_f0 = 0.009, 0.002\n",
    "# m, e_m = 2.9, 0.2\n",
    "# C_merg = 1.0\n",
    "# fn = 'ownsworth'\n",
    "\n",
    "# Mundy et al. (2016)\n",
    "tau_m, e_tau_m = 0.6*u.Gyr, 0.2*u.Gyr # Gyr\n",
    "f0, e_f0 = 0.025, 0.004\n",
    "m, e_m = 0.72, 0.20\n",
    "C_merg = 0.6\n",
    "fn = 'mundy'\n",
    "\n",
    "# Number of realizations\n",
    "N = 1000\n",
    "\n",
    "# Redshift bounds\n",
    "z_min = 0.3\n",
    "z_max = 3.0\n",
    "\n",
    "# =====================================\n",
    "\n",
    "taus = (e_tau_m * np.random.randn(N)) + tau_m\n",
    "f0s = (e_f0 * np.random.randn(N)) + f0\n",
    "ms = (e_m * np.random.randn(N)) + m\n",
    "\n",
    "# Ensure things are physical\n",
    "mask = np.logical_and(f0s > 0., taus > 0.)\n",
    "taus, f0s, ms = taus[mask], f0s[mask], ms[mask]\n",
    "\n",
    "N_merg = []\n",
    "\n",
    "print 'Using {0} / {1} realizations...'.format(mask.sum(), N)\n",
    "\n",
    "for i in range(mask.sum()):\n",
    "    N_merg_i = quad(int_fn, z_max, z_min, args=(taus[i], f0s[i], ms[i], fn, C_merg))[0]\n",
    "    N_merg.append(N_merg_i)\n",
    "    \n",
    "N_av = np.nanpercentile(N_merg, 50.)\n",
    "N_l = np.nanpercentile(N_merg, 15.6)\n",
    "N_u = np.nanpercentile(N_merg, 84.4)\n",
    "\n",
    "print 'N_merg = {0:1.2f} (+{1:1.2f}, -{2:1.2f})'.format(N_av, N_u-N_av, N_av-N_l)\n",
    "\n",
    "# Plot the distribution\n",
    "# =====================================\n",
    "fig, ax = plt.subplots(1, 1)\n",
    "n, bins, patches = ax.hist(N_merg, bins=np.arange(0, N_av + 3.*(N_u-N_av), N_av/10), \n",
    "                           normed=True, histtype='step')\n",
    "ax.plot([N_av, N_av], [0, n.max()*1.1], '-r', lw=2)\n",
    "ax.plot([N_l, N_l], [0, n.max()*1.1], '--r', lw=2)\n",
    "ax.plot([N_u, N_u], [0, n.max()*1.1], '--r', lw=2)\n",
    "ax.set_ylim(0, n.max()*1.1)\n",
    "ax.set_xlabel('$N_\\mathrm{merg}$')\n",
    "# ====================================="
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Resulting distribution of $N_\\text{merg}$ identifies the upper and lower $1\\sigma$ uncertainties on the obtained value. If using the Ownsworth et al. (2014) parameters, it shows that the quoted error of $1.2 \\pm 0.5$ was underestimated, seeing as we find $1.3^{+1.4}_{-0.5}$."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "collapsed": true
   },
   "outputs": [],
   "source": []
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 2",
   "language": "python",
   "name": "python2"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 2
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython2",
   "version": "2.7.11"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 0
}
